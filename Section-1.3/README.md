Section 1.3
=========== 

Formulating Abstractions with Higher Order Procedures
----------------------------------------------------- 

Procedures that manipulate other procedures are called "<b>higher-order procedures</b>" and are the focus of this section.

The text begins by examining the `sum-integers` procedure defined as follows:

<pre>
(define (sum-integers a b)
	(if (> a b)
	    0
	    (+ a (sum-integers (+ a 1) b))))
</pre>

It is instructive to expand this call graph, to get a sense for the computational process generated by this procedure:

<pre>
(sum-integers 1 10)
(+ 1 (sum-integers 2 10))
(+ 1 (+ 2 (sum-integers 3 10)))
(+ 1 (+ 2 (+ 3 (sum-integers 4 10))))
(+ 1 (+ 2 (+ 3 (+ 4 (sum-integers 5 10)))))
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 (sum-integers 6 10))))))
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 (+ 6 (sum-integers 7 10)))))))
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 (+ 6 (+ 7 (sum-integers 8 10))))))))
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 (+ 6 (+ 7 (+ 8 (sum-integers 9 10)))))))))
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 (+ 6 (+ 7 (+ 8 (+ 9 (sum-integers 10 10))))))))))
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 (+ 6 (+ 7 (+ 8 (+ 9 (+ 10 (sum-integers 11 10)))))))))))
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 (+ 6 (+ 7 (+ 8 (+ 9 (+ 10 0))))))))))
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 (+ 6 (+ 7 (+ 8 (+ 9 10)))))))))
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 (+ 6 (+ 7 (+ 8 19))))))))
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 (+ 6 (+ 7 27)))))))
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 (+ 6 34))))))
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 40)))))
(+ 1 (+ 2 (+ 3 (+ 4 45))))
(+ 1 (+ 2 (+ 3 49)))
(+ 1 (+ 2 52))
(+ 1 54)
55
</pre>

The procedure generates a linear recursive process.

The `sum-cubes` procedure, defined below, likewise generates a linear recursive computational process, although in this case an additional procedure (i.e., the `cube` procedure) is applied to each term in the sequence before calculating the sum:

<pre>
(define (sum-cubes a b)
	(if (> a b)
	    0
	    (+ (cube a) (sum-cubes (+ a 1) b))))
</pre>

An example call graph for `sum-cubes` might look something like the following:

<pre>
(sum-cubes 1 5)
(+ (cube 1) (sum-cubes 2 5))
(+ (cube 1) (+ (cube 2) (sum-cubes 3 5)))
(+ (cube 1) (+ (cube 2) (+ (cube 3) (sum-cubes 4 5))))
(+ (cube 1) (+ (cube 2) (+ (cube 3) (+ (cube 4) (sum-cubes 5 5)))))
(+ (cube 1) (+ (cube 2) (+ (cube 3) (+ (cube 4) (+ (cube 5) (sum-cubes 6 5))))))
(+ (cube 1) (+ (cube 2) (+ (cube 3) (+ (cube 4) (+ (cube 5) 0)))))
(+ (cube 1) (+ (cube 2) (+ (cube 3) (+ (cube 4) (+ 125 0)))))
(+ (cube 1) (+ (cube 2) (+ (cube 3) (+ (cube 4) 125))))
(+ (cube 1) (+ (cube 2) (+ (cube 3) (+ 64 125))))
(+ (cube 1) (+ (cube 2) (+ (cube 3) 189)))
(+ (cube 1) (+ (cube 2) (+ 27 189)))
(+ (cube 1) (+ (cube 2) 216))
(+ (cube 1) (+ 8 216))
(+ (cube 1) 224)
(+ 1 224)
225
</pre>

The final example given in the introduction is `pi-sum`:

<pre>
(define (pi-sum a b)
	(if (> a b)
	0
	(+ (/ 1.0 (* a (+ a 2))) (pi-sum (+ a 4) b))))
</pre>

with an example call graph like:

<pre>
(pi-sum 1 5)
(+ (/ 1.0 (* 1 (+ 1 2))) (pi-sum (+ 1 4) 5))
(+ (/ 1.0 (* 1 (+ 1 2))) (+ (/ 1.0 (* (+ 1 4) (+ (+ 1 4) 2))) (pi-sum (+ (+ 1 4) 4) 5)))
(+ (/ 1.0 (* 1 (+ 1 2))) (+ (/ 1.0 (* (+ 1 4) (+ (+ 1 4) 2))) 0))
(+ (/ 1.0 (* 1 (+ 1 2))) (+ (/ 1.0 (* (+ 1 4) (+ 5 2))) 0))
(+ (/ 1.0 (* 1 (+ 1 2))) (+ (/ 1.0 (* 5 7)) 0))
(+ (/ 1.0 (* 1 (+ 1 2))) (+ (/ 1.0 35) 0))
(+ (/ 1.0 (* 1 (+ 1 2))) (+ 0.02857142857142857 0))
(+ (/ 1.0 (* 1 (+ 1 2))) 0.02857142857142857)
(+ (/ 1.0 (* 1 3)) 0.02857142857142857)
(+ (/ 1.0 3) 0.02857142857142857)
(+ 0.3333333333 0.02857142857142857)
0.3619047619047619
</pre>

Procedures as Arguments
----------------------- 

Each of these procedures can be readily simplified by defining it in terms of the following abstraction:

<pre>
(define (sum term a next b)
	(if (> a b)
	    0
	    (+ (term a)
	       (sum term (next a) next b))))
</pre>

Notice that this abstraction requires that the procedures `term` and `next` be passed to `sum` as arguments.

We will carry through an example computation using this abstraction with the `sum-cubes` procedure.

First we (re-)define `sum-cubes` in terms of the new `sum` abstraction:

<pre>
(define (sum-cubes a b)
	(sum cube a inc b))
</pre>

Expanding the call graph for `(sum-cubes 1 5)` as before, we obtain:

<pre>
(sum-cubes 1 5)
(sum cube 1 inc 5)
(+ (cube 1) (sum cube (inc 1) inc 5))
(+ (cube 1) (+ (cube (inc 1)) (sum cube (inc (inc 1)) inc 5)))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (sum cube (inc (inc (inc 1))) inc 5))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ (cube (inc (inc (inc 1)))) (sum cube (inc (inc (inc (inc 1)))) inc 5)))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ (cube (inc (inc (inc 1)))) (+ (cube (inc (inc (inc (inc 1))))) (sum cube (inc (inc (inc (inc (inc 1))))) inc 5))))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ (cube (inc (inc (inc 1)))) (+ (cube (inc (inc (inc (inc 1))))) 0)))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ (cube (inc (inc (inc 1)))) (+ (cube (inc (inc (inc 2)))) 0)))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ (cube (inc (inc (inc 1)))) (+ (cube (inc (inc 3))) 0)))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ (cube (inc (inc (inc 1)))) (+ (cube (inc 4)) 0)))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ (cube (inc (inc (inc 1)))) (+ (cube 5) 0)))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ (cube (inc (inc (inc 1)))) (+ 125 0)))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ (cube (inc (inc (inc 1)))) 125))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ (cube (inc (inc 2))) 125))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ (cube (inc 3)) 125))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ (cube 4) 125))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ 64 125))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) 189)))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc 2)) 189)))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube 3) 189)))
(+ (cube 1) (+ (cube (inc 1)) (+ 27 189)))
(+ (cube 1) (+ (cube (inc 1)) 216))
(+ (cube 1) (+ (cube 2) 216))
(+ (cube 1) (+ 8 216))
(+ (cube 1) 224)
(+ 1 224)
225
</pre>

The call graph is not necessarily any simpler, but in terms of expressional simplicity, this second definition of `sum-cubes` is far more elegant.

Procedures as Returned Values
----------------------------- 

In addition to passing procedures as arguments to other procedures, we can also return procedures as returned values from function calls.

In order to better understand the power of this idea, let's return briefly to the `sqrt` procedure designed in Section 1.1:

<pre>
(define (sqrt x)
  (define (good-enough? guess)
    (&lt; (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
</pre>

The `sqrt` procedure encapsulates within itself three concrete ideas:

1. The idea of making a guess as to what the square root might be.
2. The idea of checking to see how accurate this guess is.
3. The idea of improving the guess, if by (2) we determine that it is not a very good guess.

Let's take a closer look at (3) above, the idea of improving the guess if it isn't good enough, and let's see if there are ways we can represent this idea in more "abstract" or general terms.

**Average Damping**

Suppose we are seeking the square root of x, that is, we are seeking a number y such that y^2=x.

This means that we are seeking a number y such that y = x/y (or, expressed in Lisp, given an "x", we are seeking "y" such that (= y (/ x y))).

If our initial guess for `y` is not good enough, it stands to reason that we might arrive at a better approximation for the square root by averaging our guess `y` with `x/y`, where `x` is the number whose square root we are seeking. Indeed, this is exactly how the `improve` procedure is defined:

<pre>
(define (improve guess)
  (average guess (/ x guess)))
</pre>

The key insight here is to realize that the expression `(/ x guess)` itself can be expressed as a particular instance of an  "anonymous" lambda function in one variable:

<pre>
(lambda (y) (/ x y))
</pre>

That is, we can re-write `improve` as follows:

<pre>
(define (improve guess)
  (average guess ((lambda (y) (/ x y)) guess)))
</pre>

This in turn suggests another abstraction, i.e., the notion of "average damping", where for a given function `f`, we would like to create a new procedure in one argument that averages that argument with the value of `f` evaluated at the argument:

<pre>
(define (average-damp f)
  (lambda (x) (average x (f x))))
</pre>

Notice that here, `average-damp` returns not a numerical value nor an "object" per se, but rather another (lambda) procedure.

This is the essence of procedures returning procedures.

With this abstraction, we can re-write `improve` as follows:

<pre>
(define (improve guess)
  ((average-damp (lambda (y) (/ x y))) guess))
</pre>

Our `sqrt` procedure now looks like:

<pre>
(define (sqrt x)
  (define (good-enough? guess)
    (&lt; (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    ((average-damp (lambda (y) (/ x y))) guess))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
</pre>

So far so good: the procedure generates the same answers as our earlier version, although it's not entirely clear whether this version is any simpler than the first one. Indeed, this version ostensibly looks even more complicated than the first, but perhaps with a bit more abstraction we'll be able to arrive at something more intuitive.

Let's investigate next point (2) above, the idea of checking to see whether the guess we make is "good enough".

**Increasing Abstraction**

As it is presently written, the `good-enough?` procedure checks to see whether the square of our guess falls within a certain, pre-defined tolerance of the number whose square root we are seeking:

<pre>
(define (good-enough? guess)
  (&lt; (abs (- (square guess) x)) 0.001))
</pre>

Suppose that `y` is our guess as to the square root of `x`, and that `(improve y)` is the next iterative improvement towards refining that guess. One way to check whether `y` is "good enough" is to calculate `(square y)` and see whether the answer comes within a certain pre-defined tolerance, exactly as is done in the `good-enough?` procedure above.

Another key insight towards generalizing our definition of `sqrt` is to realize that for computing square roots, we don't need to check whether the square of our guess comes "close enough" to the number whose square root we are seeking, but rather we simply need to check whether two successive guesses are nearly identical, since for a square root, we will have y * y = x. That is to say, let y(n) be the n-th guess we make, and let y(n+1) be the (n+1)-th guess. We should expect, then, that not only is y(n) * y(n+1) roughly equal to x, but that y(n) is roughly equal to y(n+1). 

We could, then, replace the `good-enough?` procedure with a new procedure in two arguments, which checksto see whether the two arguments are "close enough" to one another to be considered good enough to be an answer for our problem. In doing so, let's tighten up the tolerance a bit, to get a more accurate answer:

<pre>
(define (close-enough? v1 v2)
  (&lt; (abs (- v1 v2)) 0.00001))
</pre>

Clearly we're going to have to modify our `sqrt-iter` procedure as well. Instead of just passing one arugment into `good-enough?` to check to see if a guess is "good enough", we'll have to pass two arguments in to the `close-enough?` procedure: `guess` and `(improve guess)`, and see whether the two values are close qualify as the square root of the number we are seeking:

<pre>
(define (sqrt-iter guess)
  (if (close-enough? guess (improve guess))
      guess
      (sqrt-iter (improve guess))))
</pre>

Our complete `sqrt` procedure now looks like:

<pre>
(define (sqrt x)
  (define (close-enough? v1 v2)
    (&lt; (abs (- v1 v2)) 0.00001))
  (define (improve guess)
    ((average-damp (lambda (y) (/ x y))) guess))
  (define (sqrt-iter guess)
    (if (close-enough? guess (improve guess))
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
</pre>

Again, this procedure generates the same answers as the initial one, but at the added cost of invoking `improve` twice. 

Let's eliminate this inefficiency by using the keyword `let`:

<pre>
(define (sqrt x)
  (define (close-enough? v1 v2)
    (&lt; (abs (- v1 v2)) 0.00001))
  (define (improve guess)
    ((average-damp (lambda (y) (/ x y))) guess))
  (define (sqrt-iter guess)
    (let ((next-guess (improve guess)))
      (if (close-enough? guess next-guess)
          guess
          (sqrt-iter next-guess))))
  (sqrt-iter 1.0))
</pre>

Are there additional abstractions we can make, to improve the design of `sqrt` even further? It turns out there are.

**Fixed-Point Functions**

dd

[xxx]

let's keep charging ahead with our abstractions to see if we can't arrive at something which, in the end, is simpler.


 as if this version is more complicated than the first one.

---

This is illustrated nicely by the following series of examples.

Suppose that at some point we wish to calculate the average of that point with the value of some function `f` defined at that point. That is, we seek to evaluate the expression `(average x (f x))` where, as usual:

<pre>
(define (average x y)
  (/ (+ x y) 2.0))
</pre>

We can succinctly express this idea by defining the following procedure:

<pre>
(define (average-damp f)
  (lambda (x) (average x (f x))))
</pre>

That is, we can pass `f` as an argument to `average-damp`, and we will receive as the returned value a procedure in one argument which will calculate the average of that argument and f evaluated at that argument.