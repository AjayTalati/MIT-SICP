Section 1.3
=========== 

Formulating Abstractions with Higher Order Procedures
----------------------------------------------------- 

Procedures that manipulate other procedures are called "<b>higher-order procedures</b>" and are the focus of this section.

The text begins by examining the `sum-integers` procedure defined as follows:

<pre>
(define (sum-integers a b)
	(if (> a b)
	    0
	    (+ a (sum-integers (+ a 1) b))))
</pre>

It is instructive to expand this call graph, to get a sense for the computational process generated by this procedure:

<pre>
(sum-integers 1 10)
(+ 1 (sum-integers 2 10))
(+ 1 (+ 2 (sum-integers 3 10)))
(+ 1 (+ 2 (+ 3 (sum-integers 4 10))))
(+ 1 (+ 2 (+ 3 (+ 4 (sum-integers 5 10)))))
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 (sum-integers 6 10))))))
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 (+ 6 (sum-integers 7 10)))))))
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 (+ 6 (+ 7 (sum-integers 8 10))))))))
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 (+ 6 (+ 7 (+ 8 (sum-integers 9 10)))))))))
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 (+ 6 (+ 7 (+ 8 (+ 9 (sum-integers 10 10))))))))))
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 (+ 6 (+ 7 (+ 8 (+ 9 (+ 10 (sum-integers 11 10)))))))))))
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 (+ 6 (+ 7 (+ 8 (+ 9 (+ 10 0))))))))))
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 (+ 6 (+ 7 (+ 8 (+ 9 10)))))))))
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 (+ 6 (+ 7 (+ 8 19))))))))
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 (+ 6 (+ 7 27)))))))
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 (+ 6 34))))))
(+ 1 (+ 2 (+ 3 (+ 4 (+ 5 40)))))
(+ 1 (+ 2 (+ 3 (+ 4 45))))
(+ 1 (+ 2 (+ 3 49)))
(+ 1 (+ 2 52))
(+ 1 54)
55
</pre>

The procedure generates a linear recursive process.

The `sum-cubes` procedure, defined below, likewise generates a linear recursive computational process, although in this case an additional procedure (i.e., the `cube` procedure) is applied to each term in the sequence before calculating the sum:

<pre>
(define (sum-cubes a b)
	(if (> a b)
	    0
	    (+ (cube a) (sum-cubes (+ a 1) b))))
</pre>

An example call graph for `sum-cubes` might look something like the following:

<pre>
(sum-cubes 1 5)
(+ (cube 1) (sum-cubes 2 5))
(+ (cube 1) (+ (cube 2) (sum-cubes 3 5)))
(+ (cube 1) (+ (cube 2) (+ (cube 3) (sum-cubes 4 5))))
(+ (cube 1) (+ (cube 2) (+ (cube 3) (+ (cube 4) (sum-cubes 5 5)))))
(+ (cube 1) (+ (cube 2) (+ (cube 3) (+ (cube 4) (+ (cube 5) (sum-cubes 6 5))))))
(+ (cube 1) (+ (cube 2) (+ (cube 3) (+ (cube 4) (+ (cube 5) 0)))))
(+ (cube 1) (+ (cube 2) (+ (cube 3) (+ (cube 4) (+ 125 0)))))
(+ (cube 1) (+ (cube 2) (+ (cube 3) (+ (cube 4) 125))))
(+ (cube 1) (+ (cube 2) (+ (cube 3) (+ 64 125))))
(+ (cube 1) (+ (cube 2) (+ (cube 3) 189)))
(+ (cube 1) (+ (cube 2) (+ 27 189)))
(+ (cube 1) (+ (cube 2) 216))
(+ (cube 1) (+ 8 216))
(+ (cube 1) 224)
(+ 1 224)
225
</pre>

The final example given in the introduction is `pi-sum`:

<pre>
(define (pi-sum a b)
	(if (> a b)
	0
	(+ (/ 1.0 (* a (+ a 2))) (pi-sum (+ a 4) b))))
</pre>

with an example call graph like:

<pre>
(pi-sum 1 5)
(+ (/ 1.0 (* 1 (+ 1 2))) (pi-sum (+ 1 4) 5))
(+ (/ 1.0 (* 1 (+ 1 2))) (+ (/ 1.0 (* (+ 1 4) (+ (+ 1 4) 2))) (pi-sum (+ (+ 1 4) 4) 5)))
(+ (/ 1.0 (* 1 (+ 1 2))) (+ (/ 1.0 (* (+ 1 4) (+ (+ 1 4) 2))) 0))
(+ (/ 1.0 (* 1 (+ 1 2))) (+ (/ 1.0 (* (+ 1 4) (+ 5 2))) 0))
(+ (/ 1.0 (* 1 (+ 1 2))) (+ (/ 1.0 (* 5 7)) 0))
(+ (/ 1.0 (* 1 (+ 1 2))) (+ (/ 1.0 35) 0))
(+ (/ 1.0 (* 1 (+ 1 2))) (+ 0.02857142857142857 0))
(+ (/ 1.0 (* 1 (+ 1 2))) 0.02857142857142857)
(+ (/ 1.0 (* 1 3)) 0.02857142857142857)
(+ (/ 1.0 3) 0.02857142857142857)
(+ 0.3333333333 0.02857142857142857)
0.3619047619047619
</pre>

Procedures as Arguments
----------------------- 

Each of these procedures can be readily simplified by defining it in terms of the following abstraction:

<pre>
(define (sum term a next b)
	(if (> a b)
	    0
	    (+ (term a)
	       (sum term (next a) next b))))
</pre>

Notice that this abstraction requires that the procedures `term` and `next` be passed to `sum` as arguments.

We will carry through an example computation using this abstraction with the `sum-cubes` procedure.

First we (re-)define `sum-cubes` in terms of the new `sum` abstraction:

<pre>
(define (sum-cubes a b)
	(sum cube a inc b))
</pre>

Expanding the call graph for `(sum-cubes 1 5)` as before, we obtain:

<pre>
(sum-cubes 1 5)
(sum cube 1 inc 5)
(+ (cube 1) (sum cube (inc 1) inc 5))
(+ (cube 1) (+ (cube (inc 1)) (sum cube (inc (inc 1)) inc 5)))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (sum cube (inc (inc (inc 1))) inc 5))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ (cube (inc (inc (inc 1)))) (sum cube (inc (inc (inc (inc 1)))) inc 5)))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ (cube (inc (inc (inc 1)))) (+ (cube (inc (inc (inc (inc 1))))) (sum cube (inc (inc (inc (inc (inc 1))))) inc 5))))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ (cube (inc (inc (inc 1)))) (+ (cube (inc (inc (inc (inc 1))))) 0)))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ (cube (inc (inc (inc 1)))) (+ (cube (inc (inc (inc 2)))) 0)))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ (cube (inc (inc (inc 1)))) (+ (cube (inc (inc 3))) 0)))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ (cube (inc (inc (inc 1)))) (+ (cube (inc 4)) 0)))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ (cube (inc (inc (inc 1)))) (+ (cube 5) 0)))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ (cube (inc (inc (inc 1)))) (+ 125 0)))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ (cube (inc (inc (inc 1)))) 125))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ (cube (inc (inc 2))) 125))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ (cube (inc 3)) 125))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ (cube 4) 125))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) (+ 64 125))))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc (inc 1))) 189)))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube (inc 2)) 189)))
(+ (cube 1) (+ (cube (inc 1)) (+ (cube 3) 189)))
(+ (cube 1) (+ (cube (inc 1)) (+ 27 189)))
(+ (cube 1) (+ (cube (inc 1)) 216))
(+ (cube 1) (+ (cube 2) 216))
(+ (cube 1) (+ 8 216))
(+ (cube 1) 224)
(+ 1 224)
225
</pre>

Procedures as Returned Values
----------------------------- 

In addition to passing procedures as arguments to other procedures, we can also return procedures as returned values.

In order to understand the power of this idea, let's return briefly to the `sqrt` procedure designed in Section 1.1:

<pre>
(define (sqrt x)
  (define (good-enough? guess)
    (&lt; (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
</pre>

Suppose we are seeking the square root of x, that is, we are seeking a number y such that y^2=x.

This means that we are seeking a number y such that y = x/y (or, expressed in Lisp, given a "x", we are seeking "y" such that (= y (/ x y))).

---

This is illustrated nicely by the following series of examples.

Suppose that at some point we wish to calculate the average of that point with the value of some function `f` defined at that point. That is, we seek to evaluate the expression `(average x (f x))` where, as usual:

<pre>
(define (average x y)
  (/ (+ x y) 2.0))
</pre>

We can succinctly express this idea by defining the following procedure:

<pre>
(define (average-damp f)
  (lambda (x) (average x (f x))))
</pre>

That is, we can pass `f` as an argument to `average-damp`, and we will receive as the returned value a procedure in one argument which will calculate the average of that argument and f evaluated at that argument.