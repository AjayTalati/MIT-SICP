//
//  main.cpp
//  SICP-Interval1
//
//  Created by Paul Sholtz on 11/21/11.
//  Copyright 2011 __MyCompanyName__. All rights reserved.
//

#include <iostream>

#include <boost/numeric/interval.hpp>

using namespace std;
using namespace boost::numeric;

// procedure declarations
float width(interval<float> f);

// procedure definitions
float width(interval<float> f) {
    return (f.upper() - f.lower())/2.0f;
}

/*************************************************************** 
 
 The output generated by this program is the following, which 
 corresponds with the output generated by the reference Scheme 
 implementation:
 
 Interval (1) Width: 0.5
 Interval (2) Width: 0.5
 Interval (3) Width: 0.5
 
 Interval (1*2) Width: 2.5
 Interval (1*3) Width: 3.5
 Interval (2*3) Width: 4.5
 
 Interval (1*1) Width: 1.5
 Interval (2*2) Width: 3.5
 Interval (3*3) Width: 5.5
 
 =========
 Divisions
 =========
 Interval (1/2) Width: 0.208333
 Interval (2/1) Width: 1.25
 
 Interval (1/3) Width: 0.116667
 Interval (3/1) Width: 1.75
 
 Interval (2/3) Width: 0.15
 Interval (3/2) Width: 0.375
 
 Interval (1/1) Width: 0.75
 Interval (2/2) Width: 0.291667
 Interval (3/3) Width: 0.183333
 
 **************************************************************/
int main (int argc, const char * argv[])
{    
    interval<float> i1(1.0f, 2.0f);
    interval<float> i2(3.0f, 4.0f);
    interval<float> i3(5.0f, 6.0f);
    
    // all these intervals have the same width:
    cout << "Interval (1) Width: " << width(i1) << endl;
    cout << "Interval (2) Width: " << width(i2) << endl;
    cout << "Interval (3) Width: " << width(i3) << endl; 
    cout << endl;
    
    // however, the products generated by multiplying these intervals together have different values:
    cout << "Interval (1*2) Width: " << width(i1*i2) << endl;
    cout << "Interval (1*3) Width: " << width(i1*i3) << endl; 
    cout << "Interval (2*3) Width: " << width(i2*i3) << endl; 
    cout << endl; 
    
    // indeed, even the width of the "squares" of the intervals varies, despite the fact that the intervals have constant widths:
    cout << "Interval (1*1) Width: " << width(i1*i1) << endl;
    cout << "Interval (2*2) Width: " << width(i2*i2) << endl;
    cout << "Interval (3*3) Width: " << width(i3*i3) << endl; 
    cout << endl;
    
    // similar results are obtained when using the "divide interval" procedure:
    cout << "=========" << endl;
    cout << "Divisions" << endl;
    cout << "=========" << endl; 
    cout << "Interval (1/2) Width: " << width(i1/i2) << endl; 
    cout << "Interval (2/1) Width: " << width(i2/i1) << endl; 
    cout << endl; 
    
    cout << "Interval (1/3) Width: " << width(i1/i3) << endl;
    cout << "Interval (3/1) Width: " << width(i3/i1) << endl;
    cout << endl;
    
    cout << "Interval (2/3) Width: " << width(i2/i3) << endl;
    cout << "Interval (3/2) Width: " << width(i3/i2) << endl; 
    cout << endl; 
    
    cout << "Interval (1/1) Width: " << width(i1/i1) << endl;
    cout << "Interval (2/2) Width: " << width(i2/i2) << endl;
    cout << "Interval (3/3) Width: " << width(i3/i3) << endl; 
    
    return 0;
}

