Exercise 1.14
=============

Draw the tree illustrating the process generated by the `count-change` procedure of section 1.2.2 in making
change for 11 cents. What are the orders of growth of the space and number of steps used by this process as 
the amount to be changed increases?

Solution
-------- 

The accompanying .scm file gives the call graph of `(count-change 11)` as expressed in Scheme. 

As indicated in that file, the procedure `count-change` is invoked a total of 55 times.

In terms of visually rendering the call graph, there are several possible ways of doing this.

### 3-Dimensional Call Graph

The illustration below depicts a 3-D model of the call graph:

[![](http://farm7.static.flickr.com/6028/5915943634_3a5c363e50.jpg)](http://farm7.static.flickr.com/6028/5915943634_3a5c363e50.jpg)

[*Generated by Ubigraph*](http://ubietylab.net/ubigraph/)

Each ball represents a call to the `count-change` procedure. Accordingly, there are 55 balls in all.

Entrance into `count-change` at `(count-change 11)` is represented by the red ball.

Purple balls represent branch points.

Green balls represent "leaves" where the recursion bottoms out.

### Numerical Call Graph

A more "quantitative" representation of the call graph is given in the figure below:

[![](http://farm7.static.flickr.com/6007/5909620677_a7b954b3ed_b.jpg)](http://farm7.static.flickr.com/6007/5909620677_a7b954b3ed_b.jpg)

[*Generated by GraphViz*](http://www.graphviz.org/)

The procedure generates a <strong>tree-recursive</strong> computational process.

### Analytical Performance Evaluation

Let's define a function N(n,m), which will represent the number of operations performed by the subbranch `(cc n m)`. 

We would like to understand how the performance of the procedure `(cc n 5)` scales with n.

The definition of `cc` is given by:

```Scheme
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins)) 
                     kinds-of-coins)))))
```

and, for reference, the definition of `first-denomination` is:

```Scheme
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
```

We begin by expanding the expression for `N(n,5)`:

```scheme
N(n,5) = 1 + N(n,4) + N(n-50,5)
```

Let's "recursively" expand the first subexpression `N(n,4)` as follows:

```scheme
N(n,4) = 1 + N(n,3) + N(n-25,4)
```

We continue expanding the first subexpression until the recursion terminates:

```scheme
N(n,3) = 1 + N(n,2) + N(n-10,3)
N(n,2) = 1 + N(n,1) + N(n-5,2)
N(n,1) = 1 + N(n,0) + N(n-1,1)
```

The recursion stops at `(cc n 0)`, where it returns 0 and performs only 1 operation:

```scheme
N(n,0) = 1
```

so that:

```scheme
N(n,1) = 1 + 1 + N(n-1,1) = 2 + N(n-1,1)
```

But expanding the first subexpression `N(n-1,1)` again, we obtain:

```scheme
N(n-1,1) = 2 + N(n-2,1)
```

so that:

```scheme
N(n,1) = 4 + N(n-2,1)
```

Continuing until we reach `N(0,1)`:

```scheme
N(n,1) = 2n + N(0,1)
```

and since `N(0,1) = 1`, we have:

```scheme
N(n,1) = 2n + 1
```

To verify this, simply refer to the (quantitative) call graph above:

* The subtree beneath `(cc 2 1)` consists of 5 nodes. 
* The subtree beneath `(cc 6 1)` consists of 13 nodes.
* The subtree beneath `(cc 11 1)` consists of 23 nodes.

Always the subtree beneath `(cc n 1)` produces `2n+1` nodes. 

Now consider our expression for `N(n,2)`:

```scheme
N(n,2) = 1 + N(n,1) + N(n-5,2) 
N(n,2) = 1 + 2n + 1 + N(n-5,2) 
N(n,2) = 2(n+1) + N(n-5,2)
```

and now expanding the subexpression for `N(n-5,2)`:

```scheme
N(n-5,2) = 2(n+1) + N(n-10,2)
```

so that:

```scheme
N(n,2) = 4(n+1) + N(n-10,2)
```

In this case, the recursion will bottom out after (roughly) n/5 steps, so that the number of operations required to evaluate N(n,2) is rough (2/5)n(n+1), or in other words, is of order n^2. We can write:

```scheme
N(n,2) = O(n^2)
```

Working our way back up the recursion tree, it should be clear now how the process will evolve. For `N(n,3)` we can write:

```scheme
N(n,3) = 1 + N(n,2) + N(n-10,3)
N(n,3) = O(n^2) + N(n-10,3)
```

and since:

```scheme
N(n-10,3) = O(n^2) + N(n-20,3)
```

and since this recursion will bottom out after (approximately) n/10 calls, we can write:

```scheme
N(n,3) = O(n^3)
```

and similarly:

```scheme
N(n,4) = O(n^4)
N(n,5) = O(n^5)
```

So we expect calls to `(count-change n)` to scale with the fifth power of n, as n increases. That is, we have order of growth O(n^5) in time. The order of growth in terms of space scales at the same rate as does the number of steps required, that is, it too scales at O(n^5). This can be seen again, for example, by looking at the quantitative call graph and seeing how much space is required (i.e., cells) must be allocated to complete the calculation.


### Numerical Performance Evaluation

Although we are not specifically required to do so, I can scarcely resist an opportunity to indulge vicariously in a little numerical linear algebra to see how well this analysis holds up in practice. The accompanying `exercise1-14-stats.py` file counts the number of invocations of `cc` for `(cc n k)` as k scales from 1 to 5. The collected statistics (expressed as "Lisp-ish-ly" as we can) are as follows:

```scheme
(invocation-count (cc n 1) 100) ==> (list 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 
57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99 101 103 105 107 109 111 113 115 117 119 121 123 125 127 
129 131 133 135 137 139 141 143 145 147 149 151 153 155 157 159 161 163 165 167 169 171 173 175 177 179 181 183 185 187 
189 191 193 195 197 199 201)
```

For k=1, our model predicts that the number of invocations to `cc` will scale linearly as 2n+1, which, indeed, is precisely the behavior we observe. In this case, regression analysis will be of little quantitative value, although we can still carry the calculation out just for the fun of it, if for no other reason. Details on how to carry out the regression analysis are given in the corresponding Wiki entry. In this case, the regression yields values of `x = [1 2]`, that is to say, the best-fit curve looks like `y = 2x + 1`, which is precisely what we anticipated.

The corresponding plot in Octave looks something like the following:

[![](http://farm7.static.flickr.com/6148/5947047384_9d762b1a1a.jpg)](http://farm7.static.flickr.com/6148/5947047384_9d762b1a1a.jpg)

The "+" characters indicate the scatterplot of the collected statistics, and the blue line indicates the best-fit regression line passing through these points. The regression curve is the best fit polynomial of degree m = k. In this case, since k = 1, the regression curve is linear (or rather, strictly speaking, affine). Regression curves for subsequent examples will be polynomials of increasing degree.

----
For the remaining values of k, the results are as follows:

```scheme
(invocation-count (cc n 2) 100) ==> (list 5 7 9 11 13 19 23 27 31 35 43 49 55 61 67 77 85 93 101 109 121 131 141 151 161 
175 187 199 211 223 239 253 267 281 295 313 329 345 361 377 397 415 433 451 469 491 511 531 551 571 595 617 639 661 683 709 
733 757 781 805 833 859 885 911 937 967 995 1023 1051 1079 1111 1141 1171 1201 1231 1265 1297 1329 1361 1393 1429 1463 1497 
1531 1565 1603 1639 1675 1711 1747 1787 1825 1863 1901 1939 1981 2021 2061 2101 2141)
```

Regression analysis for k=2 yields values of `x = [2.671 1.39866 0.2]`, that is, the best fit curve is `y = 2.671 x^2 + 1.39866 x + 0.2`:

[![](http://farm7.static.flickr.com/6021/5947047422_10805b113d.jpg)](http://farm7.static.flickr.com/6021/5947047422_10805b113d.jpg)

----

```scheme
(invocation-count (cc n 3) 100) ==> (list 7 9 11 13 15 21 25 29 33 37 51 59 67 75 83 99 111 123 135 147 173 191 209 227 
245 275 299 323 347 371 413 445 477 509 541 589 629 669 709 749 811 861 911 961 1011 1081 1141 1201 1261 1321 1407 1479 
1551 1623 1695 1791 1875 1959 2043 2127 2241 2339 2437 2535 2633 2759 2871 2983 3095 3207 3353 3481 3609 3737 3865 4025 
4169 4313 4457 4601 4783 4945 5107 5269 5431 5629 5809 5989 6169 6349 6571 6771 6971 7171 7371 7611 7831 8051 8271 8491)
```

Regression analysis for k=3 yields `x = [5.168 1.1252 0.174 0.0066].

The best fit curve is (roughly) `y = 5.168 x^3 + 1.1252 + x^2 + 0.174x`:

[![](http://farm7.static.flickr.com/6145/5946494323_16a9aeeba2.jpg)](http://farm7.static.flickr.com/6145/5946494323_16a9aeeba2.jpg)

----

```scheme
(invocation-count (cc n 4) 100) ==> (list 9 11 13 15 17 23 27 31 35 39 53 61 69 77 85 101 113 125 137 149 175 193 211 229 
247 285 311 337 363 389 437 473 509 545 581 643 691 739 787 835 913 975 1037 1099 1161 1257 1335 1413 1491 1569 1693 1791 
1889 1987 2085 2229 2349 2469 2589 2709 2885 3031 3177 3323 3469 3673 3847 4021 4195 4369 4611 4817 5023 5229 5435 5719 
5961 6203 6445 6687 7013 7295 7577 7859 8141 8515 8841 9167 9493 9819 10245 10619 10993 11367 11741 12223 12649 13075 
13501 13927)
```

Regression analysis for k=4 yields `x = [3.9818 2.073 1.2845e-01 6.0712e-03 6.4004e-05]`.

The best fit curve is (roughly) `y = 3.9818 x^4 + 2.073 x^3`. 

It's worth noting that this matrix is very poorly conditioned, with the ratio between largest and smallest eigenvalues being roughly 3.33e+16.

[![](http://farm7.static.flickr.com/6005/5946494371_a35673c5e9.jpg)](http://farm7.static.flickr.com/6005/5946494371_a35673c5e9.jpg)

----

```scheme
(invocation-count (cc n 5) 100) ==> (list 11 13 15 17 19 25 29 33 37 41 55 63 71 79 87 103 115 127 139 151 177 195 213 231 
249 287 313 339 365 391 439 475 511 547 583 645 693 741 789 837 915 977 1039 1101 1163 1259 1337 1415 1493 1571 1705 1805 
1905 2005 2105 2255 2379 2503 2627 2751 2941 3095 3249 3403 3557 3777 3963 4149 4335 4521 4789 5013 5237 5461 5685 6007 
6275 6543 6811 7079 7453 7771 8089 8407 8725 9161 9535 9909 10283 10657 11161 11597 12033 12469 12905 13483 13987 14491 
14995 15499)
```

Regression analysis for k=5 yields `x = [18.033 -1.7199 4.1779e-01 -1.9385e-03 1.4051e-04 -5.8625e-08]`.

The best fit curve is (roughly) `y = 18.033 x^5 - 1.7199 x^4`.

It's worth noting that this matrix is very poorly conditioned, with the ratio between largest and smallest eigenvalues being roughly 4.26e+20.

[![](http://farm7.static.flickr.com/6020/5947047566_aa7b6c50f0.jpg)](http://farm7.static.flickr.com/6020/5947047566_aa7b6c50f0.jpg)?
